Lecture;Topic;Section;Text
7;Public Key Cryptography;Public Key Cryptography I;"The basic setting for cryptography is typically described via a cast of three characters: Alice and Bob, who with to communicate confidentially over some (insecure) link, and Eve, an eavesdropper who is listening in and trying to discover what they are saying. Let’s assume that Alice wants to transmit a message x (written in binary) to Bob. She will apply her encryption function E to x and send the encrypted message E(x) over the link; Bob, upon receipt of E(x), will then apply his decryption function D to it and thus recover the original message: i.e., D(E(x)) = x."
7;Public Key Cryptography;Public Key Cryptography II;"Since the link is insecure, Alice and Bob have to assume that Eve may get hold of E(x). (Think of Eve as being a “sniffer” on the network.) Thus ideally we would like to know that the encryption function E is chosen so that just knowing E(x) (without knowing the decryption function D) doesn’t allow one to discover anything about the original message x."
7;Public Key Cryptography;Public Key Cryptography III ;"The central idea behind the RSA cryptosystem is that Bob is able to implement a digital lock, to which only he has the key. Now by making this digital lock public, he gives Alice (or, indeed, anybody else) a way to send him a secure message which only he can open. Here is how the digital lock is implemented in the RSA scheme. Each person has a public key known to the whole world, and a private key known only to him- or herself. "
7;Public Key Cryptography;Public Key Cryptography IV;"The RSA scheme is based heavily on modular arithmetic. Let p and q be two large primes (typically having, say, 512 bits each), and let N = pq. We will think of messages to Bob as numbers modulo N, excluding the trivial values 0 and 1. Also, let e be any number that is relatively prime to (p − 1)(q − 1). Then Bob’s public key is the pair of numbers (N, e). This pair is published to the whole world. Bob’s private key is the number d, which is the inverse of e mod (p − 1)(q − 1)."
7;Public Key Cryptography;Encryption;"[Encryption]: When Alice wants to send a message x (assumed to be an integer mod N) to Bob, she computes the value E(x) ≡ xe (mod N) and sends this to Bob."
7;Public Key Cryptography;Decryption ;"[Decryption]: Upon receiving the value y = E(x), Bob computes D(y) ≡ yd (mod N); this will be equal to the original message x."
7;Public Key Cryptography;Fermat’s Little Theorem;"For any prime p and any a ∈ {1, 2, . . . , p − 1}, we have a^(p−1) ≡ 1 (mod p). Proof. Let S denote the set of non-zero integers mod p, i.e., S = {1, 2, . . . , p − 1}. Consider the  sequence of numbers a, 2a, 3a, . . . , (p − 1)a mod p. We already saw that, whenever gcd(p, a) = 1 (i.e., p, a are coprime, which certainly holds here since p is prime) these numbers are all distinct. Therefore, since none of them is zero, and there are p − 1 of them, they must include each element of S exactly once. Therefore, the set of numbers S′ = {a (mod p), 2a (mod p), . . . , (p − 1)a (mod p)}. is exactly the same as S.  Now suppose we take the product of all numbers in S, mod p. Clearly, this product is 1 × 2 × · · · × (p − 1) ≡ (p − 1)! (mod p). (1) On the other hand, what if we take the product of all the numbers in S′? Clearly this is a × 2a × · · · × (p − 1)a ≡ ap−1(p − 1)! (mod p). But from our observation in the previous paragraph that the sets of numbers in S and in S′ are exactly the same (mod p), the products in (1) and (2) must in fact be equal mod p. Hence we have (p − 1)! ≡ a(p−1)(p − 1)! (mod p). Finally, since p is prime, we know that every non-zero integer has an inverse mod p, and therefore (p − 1)! has an inverse mod p. Hence we can multiply both sides by the inverse of (p − 1)! to get a(p−1) ≡ 1 (mod p), as required."
7;Public Key Cryptography;Correctness of RSA.;"Theorem 7.1: Under the above definitions of the encryption and decryption functions E and D, we have D(E(x)) ≡ x (mod N) for every possible message x ∈ {0, 1, . . . , N − 1}. To prove the statement, we have to show that (x^e)^d ≡ x (mod N) for every x $\in$ {0, 1, . . . , N − 1}. Let’s consider the exponent, which is ed. By definition of d, we know that ed ≡ 1 (mod (p − 1)(q − 1)); hence we can write ed = 1 + k(p − 1)(q − 1) for some integer k, and therefore xed − x = x1+k(p−1)(q−1) − x = x(xk(p−1)(q−1) − 1). Looking back, our goal is to show that this last expression is equal to 0 mod N for every x. Now we claim that the expression x(xk(p−1)(q−1) − 1) is divisible by p. To see this, we consider two cases: Case 1: x is not a multiple of p. In this case, since x̸ ≡ 0 (mod p), we can use Fermat’s Little Theorem to deduce that x(p−1) ≡ 1 (mod p), and hence xk(p−1)(q−1) − 1 ≡ 0 (mod p), as required. Case 2: x is a multiple of p. In this case the expression in (5), which has x as a factor, is clearly divisible by p. By an entirely symmetrical argument, x(xk(p−1)(q−1) − 1) is also divisible by q. Therefore, it is divisible by both p and q, and since p and q are primes it must be divisible by their product, pq = N. But this implies that the expression is equal to 0 mod N, which is exactly what we wanted to prove. "
7;Public Key Cryptography;Security ;"The security of RSA hinges upon the following basic assumption: Given N, e and y ≡ xe (mod N), there is no efficient algorithm for determining x. The security of RSA has not been formally proved: it rests on the assumptions that breaking RSA is essentially tantamount to factoring N, and that factoring is hard."
7;Public Key Cryptography;Prime Number Theorem;"Let π(n) denote the number of primes that are less than or equal to n. Then for all n ≥ 17, we have π(n) ≥ n/ln n .(And in fact, lim n→∞ π(n) = n/ ln n = 1.)"
7;Public Key Cryptography;Summary;"To summarize, then, in the RSA protocol Bob need only perform simple calculations such as multiplication, exponentiation and primality testing to implement his digital lock. Similarly, Alice and Bob need only perform simple calculations to lock and unlock the message respectively. By contrast, to unlock the message without the key, Eve would have to perform operations like factoring large numbers, which (at least according to widely accepted belief) requires more computational power than all the world’s most sophisticated computers combined!"
